<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн
| Пишем ботов для Telegram на языке Python</title><link rel=stylesheet href=/test-web/css/override.css><link rel=stylesheet href=/telegram-tutorial/book.min.b7c4a27ae7333f2fd90f74328a06079ce9a887b15763d645a1ce5ad459fe9881.css><meta property="og:title" content="Пишем ботов для Telegram на языке Python"><meta property="og:image" content="https://telegram.org/file/811140058/2/7GzMJk4Ij54/a1649c56fa9f805828"><meta property="og:description" content="Учебник для ботописателей"><link rel=icon href=/telegram-tutorial/favicon.png type=image/x-icon></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://mastergroosha.github.io/telegram-tutorial/>Пишем ботов для Telegram на языке Python</a></h2><style>nav ul a[href$=\2ftelegram-tutorial\2f docs\2flesson_09\2f ]{color:#004ed0}</style><ul><li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li><li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. “Угадай мелодию”. Подготовка</a></li><li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. “Угадай мелодию”. Завершаем бота</a></li><li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li><li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li><li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan</a></li><li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li><li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li><li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li><li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в группах</a></li><li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li><li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном сервере</a></li></ul></nav></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/telegram-tutorial/svg/menu.svg alt=Menu></label></header><header class=markdown><h1>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</h1></header><article class=markdown><p>⁠</p><p><a href=/telegram-tutorial/docs/lesson_09/>Продолжаю</a> рассказывать о нововведениях в Bot API версии 2. Я не буду рассказывать о методах <a href=https://core.telegram.org/bots/api#getchat>getChat</a>, <a href=https://core.telegram.org/bots/api#getchatmember>getChatMember</a> и т.д., которые <a href=https://core.telegram.org/bots/api#recent-changes>появились</a> в обновлении 2.1: они интуитивно понятны и особых проблем не вызывают. Вопросы могут возникнуть при изучении специальных обычных кнопок, вроде тех, что запрашивают у вас номер телефона и геолокацию, при попытке получить отредактированное сообщение, а также при работе с уже загруженными в облако объектами с инлайн-режимом. Обо всём по порядку.</p><h2 id=->Специальные кнопки</h2><p>Некоторым ботам жизненно необходим ваш номер телефона или местоположение, например, для привязки к учётным записям на других сайтах или же поиска близлежащих объектов на карте. Разработчики Telegram прислушались к мнению ботоводов и добавили особые свойства обычным (не инлайновым) кнопкам. Итак, чтобы запросить номер телефона, нужно помимо аргумента <code>text</code> передать аргумент <code>request_contact=True</code>, а для геолокации, соответственно, <code>request_location=True</code>. Обратите внимание, что одновременно у кнопки может быть не больше одного особого свойства (можно не указывать никакой), а также что специальные кнопки могут быть отправлены только в диалоги (бот-человек). Напишем код, который на команду <strong>/geophone</strong> отправит нам клавиатуру с этими кнопками.</p><pre><code class=language-none data-lang=none># не забудьте про from telebot import types
@bot.message_handler(commands=["geophone"])
def geophone(message):
    # Эти параметры для клавиатуры необязательны, просто для удобства
    keyboard = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
    button_phone = types.KeyboardButton(text="Отправить номер телефона", request_contact=True)
    button_geo = types.KeyboardButton(text="Отправить местоположение", request_location=True)
    keyboard.add(button_phone, button_geo)
    bot.send_message(message.chat.id, "Отправь мне свой номер телефона или поделись местоположением, жалкий человечишка!", reply_markup=keyboard)</code></pre><p>При нажатии на кнопку отправки номера телефона сервер вернёт объект Message с непустым типом <a href=https://core.telegram.org/bots/api#contact>Contact</a>, а при нажатии на кнопку отправки геолокации – с непустым типом <a href=https://core.telegram.org/bots/api#location>Location</a>.</p><p><strong>Важно</strong>: если вы используете <a href=/telegram-tutorial/docs/lesson_11/>конечные автоматы</a> или любой другой механизм состояний, который будет ждать от пользователя его телефон в объекте Contact, помните, что ушлый юзер может попробовать обмануть бота и скинуть любой другой контакт из записной книжки. Чтобы убедиться, что номер телефона принадлежит именно этому конкретному пользователю, сравните <code>user_id</code> в объекте <code>from</code> с <code>user_id</code> в объекте <code>Contact</code>, они должны совпадать.</p><h2 id=-->Редактирование сообщений пользователями</h2><p>Начиная с <a href=https://telegram.org/blog/edit>мая 2016 года</a>, пользователи могут редактировать свои сообщения, а боты могут видеть исправления. Как им в этом помочь, давайте разберёмся вместе. В качестве примера заставим нашего бота отвечать на ругательства. К примеру, если пользователь пишет &ldquo;дурак&rdquo;, бот ответит &ldquo;сам дурак&rdquo;. Хитрые люди могут попробовать отредактировать своё сообщение и выставить бота в дурном свете, но мы будем изменять ответ бота под пользовательский текст.</p><p>Для отслеживания изменений, у нас в копилке появился новый тип хэндлеров – <code>edited_message_handler</code>, который настраивается точно так же, как и <code>message_handler</code>, просто &ldquo;ловит&rdquo; он только те сообщения, которые отредактированы. Что ж, ничего сложного, пишем!</p><pre><code class=language-none data-lang=none>@bot.message_handler(func=lambda message: True)
def any_message(message):
    bot.reply_to(message, "Сам {!s}".format(message.text))


@bot.edited_message_handler(func=lambda message: True)
def edit_message(message):
    bot.edit_message_text(chat_id=message.chat.id,
                          text= "Сам {!s}".format(message.text),
                          message_id=message.message_id + 1)</code></pre><p>Заметили? Да, при вызове <code>edit_message_text</code> надо указать <code>message_id</code> на единицу бОльший, чем тот, который прислан сервером, потому что сервер сообщает о сообщении от пользователя, а нам нужно редактировать сообщение бота, которое шло за ним следом. И вот как это будет выглядеть (это одни и те же сообщения, что видно по метке &ldquo;изм.&rdquo; около моего)</p><h2 id=-1>Кэшированный инлайн</h2><p>Когда <a href=https://core.telegram.org/bots/inline>инлайн-боты</a> только появились, то в качестве источника данных для ответов надо было указывать внешние ссылки, причем с ограничениями по размеру указываемого файла. Очевидно, такой подход мог быть не очень быстрым, а чем дольше пользователь ждёт, тем он менее доволен результатами работы бота :) В итоге, в Bot API v2 инлайн-режиму разрешили в качестве источника для медиа использовать <code>file_id</code> уже имеющихся на сервере файлов (<em>напомню, что <code>file_id</code> для одного и того же файла будут разниться от бота к боту</em>) Итак, у меня есть <code>file_id</code> двух фотографий с <a href=https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D0%BF%D0%B8%D0%B1%D0%B0%D1%80%D0%B0>капибарами</a> (как получить <code>file_id</code> загружаемых боту фотографий, считайте это заданием для самоподготовки), надо на любой инлайн-запрос (даже пустой) предложить эти 2 изображения. По сути, всё сводится к замене типа <code>InlineQueryResultPhoto</code> на тип <code>InlineQueryResultCachedPhoto</code></p><pre><code class=language-none data-lang=none>@bot.inline_handler(func=lambda query: True)
def inline_mode(query):
    capibara1 = types.InlineQueryResultCachedPhoto(
        id="1",
        photo_file_id="AgADAgAD6rMxGyBnGwABgBmcoHgy01IENAAQSYK_1gyoAAU-5aQACAg",
        caption="Это капибара №1"
    )
    capibara2 = types.InlineQueryResultCachedPhoto(
        id="2",
        photo_file_id="AgADAgAD67MxGyBnGwABCvqPIYxMoNHENAAS51HjO88y_Z0ffAQABAg",
        caption="Это капибара №2"
    )
    bot.answer_inline_query(query.id, [capibara1, capibara2])</code></pre><p>Запускаем бота. Ура, теперь мы умеем очень быстро предлагать разных капибар нашим пользователям :)</p><p>Помимо фотографий, из &ldquo;кэша&rdquo; можно показывать любые типы, поддерживаемые мессенджером: видео, аудио, стикеры, файлы (пока что только <code>pdf</code> и <code>zip</code>).</p><p>На этом всё. <strong>Хороших ботов</strong>!</p><p><a href=/telegram-tutorial/docs/lesson_08/ class=book-btn style=float:left>← Урок №8</a>
<a href=/telegram-tutorial/docs/lesson_10/ class=book-btn style=float:right>Урок №10 →</a></p></article></div><aside class="book-toc level-3 fixed"><nav id=TableOfContents><ul><li><a href=#->Специальные кнопки</a></li><li><a href=#-->Редактирование сообщений пользователями</a></li><li><a href=#-1>Кэшированный инлайн</a></li></ul></nav></aside></main></body></html>