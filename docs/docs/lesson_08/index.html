<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Урок 8. Bot API v2: Кнопки и редактирование сообщений
| Пишем ботов для Telegram на языке Python</title><link rel=stylesheet href=/test-web/css/override.css><link rel=stylesheet href=/telegram-tutorial/book.min.b7c4a27ae7333f2fd90f74328a06079ce9a887b15763d645a1ce5ad459fe9881.css><meta property="og:title" content="Пишем ботов для Telegram на языке Python"><meta property="og:image" content="https://telegram.org/file/811140058/2/7GzMJk4Ij54/a1649c56fa9f805828"><meta property="og:description" content="Учебник для ботописателей"><link rel=icon href=/telegram-tutorial/favicon.png type=image/x-icon></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://mastergroosha.github.io/telegram-tutorial/>Пишем ботов для Telegram на языке Python</a></h2><style>nav ul a[href$=\2ftelegram-tutorial\2f docs\2flesson_08\2f ]{color:#004ed0}</style><ul><li><a href=/telegram-tutorial/docs/lesson_00/>Урок 0. Подготовка рабочего места в Windows и Linux. Virtual Environment (venv). Ответы на вопросы</a></li><li><a href=/telegram-tutorial/docs/lesson_01/>Урок 1. Введение, простой echo-бот</a></li><li><a href=/telegram-tutorial/docs/lesson_02/>Урок 2. “Угадай мелодию”. Подготовка</a></li><li><a href=/telegram-tutorial/docs/lesson_03/>Урок 3. “Угадай мелодию”. Завершаем бота</a></li><li><a href=/telegram-tutorial/docs/lesson_04/>Урок 4. Вебхуки</a></li><li><a href=/telegram-tutorial/docs/lesson_05/>Урок 5. Автопостинг в каналы</a></li><li><a href=/telegram-tutorial/docs/lesson_06/>Урок 6. Собираем аналитику при помощи Botan</a></li><li><a href=/telegram-tutorial/docs/lesson_07/>Урок 7. Встраиваемые боты (Inline)</a></li><li><a href=/telegram-tutorial/docs/lesson_08/>Урок 8. Bot API v2: Кнопки и редактирование сообщений</a></li><li><a href=/telegram-tutorial/docs/lesson_09/>Урок 9. Bot API v2: Специальные кнопки, опять редактирование сообщений, кэшированный инлайн</a></li><li><a href=/telegram-tutorial/docs/lesson_10/>Урок 10. Bot API v3. Автоматизируем работу в группах</a></li><li><a href=/telegram-tutorial/docs/lesson_11/>Урок 11. Ведём (более-менее) осмысленные диалоги. Конечные автоматы</a></li><li><a href=/telegram-tutorial/docs/lesson_12/>Урок 12. Запускаем несколько ботов на одном сервере</a></li></ul></nav></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/telegram-tutorial/svg/menu.svg alt=Menu></label></header><header class=markdown><h1>Урок 8. Bot API v2: Кнопки и редактирование сообщений</h1></header><article class=markdown><h2 id=heading>Введение</h2><p>В начале апреля 2016 года <a href=https://telegram.org/blog/bots-2-0>вышло</a> первое по-настоящему крупное обновление API для ботов. Изменений довольно много, поэтому материал я разобью на несколько частей. Сегодня поговорим об inline-кнопках и редактировании сообщений, а затем обсудим новые инлайн-режимы вместе со специальными кнопками для отправки геолокации и номера телефона.</p><h2 id=->Новые возможности</h2><p>Начнём с двух важных изменений:</p><ol><li>Каждая кнопка, будь то обычная или инлайн, это теперь самостоятельный объект <code>KeyboardButton</code> или <code>InlineKeyboardButton</code>, не забудьте обновить своих ботов!</li><li>В Inline-режиме все текстовые поля теперь представлены отдельными объектами <code>InputMessageContent</code>, которые, в свою очередь могут быть аж 4-х типов (подробности <a href=https://core.telegram.org/bots/api#inputmessagecontent>тут</a>).</li></ol><h3 id=url->URL-кнопки</h3><p>Итак, <strong>инлайн-кнопки</strong>. Что это такое? Это специальные объекты, которые &ldquo;цепляются&rdquo; к конкретным сообщениям и распространяют своё действие, в общем случае, только на них. Делятся такие кнопки на три типа: URL-кнопки, Callback-кнопки и Switch-кнопки.
Самыми простыми являются кнопки-ссылки (URL). Как видно из названия, их цель - просто перекидывать пользователей по определенным веб-адресам. Давайте сразу напишем обработчик, который будет на любое сообщение отвечать каким-либо текстом и предложением перейти, например, на Яндекс.</p><pre><code class=language-none data-lang=none>@bot.message_handler(content_types=["text"])
def default_test(message):
    keyboard = types.InlineKeyboardMarkup()
    url_button = types.InlineKeyboardButton(text="Перейти на Яндекс", url="https://ya.ru")
    keyboard.add(url_button)
    bot.send_message(message.chat.id, "Привет! Нажми на кнопку и перейди в поисковик.", reply_markup=keyboard)</code></pre><p>Инлайн-клавиатура представляет собой объект <code>InlineKeyboardMarkup</code>, а каждая инлайн-кнопка – это объект <code>InlineKeyboardButton</code>. Чтобы получилась URL-кнопка, нужно указать значения параметров <code>text</code> (текст на кнопке) и <code>url</code> (валидный веб-адрес). В результате бот пришлет нам такое сообщение (см. рис.). В целях обеспечения безопасности, перед переходом по URL-кнопкам появляется всплывающее окно, в котором видна ссылка целиком.</p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/test-web/images/l8_1.png alt=URL-кнопка><figcaption><h4><i>URL-кнопка</i></h4></figcaption></figure></center><h3 id=callback---->Callback-кнопки и редактирование сообщений</h3><p>Прежде, чем мы перейдем к другим кнопкам, давайте познакомимся с функциями редактирования сообщений, коих тоже три: <code>editMessageText</code> (редактирование текста), <code>editMessageCaption</code> (редактирование подписи к медиа) и <code>editMessageReplyMarkup</code> (редактирование инлайн-клавиатуры). В рамках этого урока рассмотрим только первую функцию, остальные работают аналогично и предлагаются для самостоятельного изучения.<br>Чтобы отредактировать сообщение, нам надо знать, про какое именно идёт речь. В случае, если оно было отправлено самим ботом, идентификаторами служит связка <code>chat_id</code> + <code>message_id</code>. Но если сообщение было отправлено в инлайн-режиме, то ориентироваться надо по параметру <code>inline_message_id</code>.</p><p>И вот теперь вернемся к нашим <del>баранам</del> кнопкам. На очереди – <strong>Callback</strong>. Это, на мой взгляд, самая крутая фича нового обновления. Колбэк-кнопки позволяют выполнять произвольные действия по их нажатию. Всё зависит от того, какие параметры каждая кнопка в себе несёт. Соответственно, все нажатия будут приводить к отправке боту объекта <code>CallbackQuery</code>, содержащему поле <code>data</code>, в котором написана некоторая строка, заложенная в кнопку, а также либо объект <code>Message</code>, если сообщение отправлено ботом в обычном режиме, либо поле <code>inline_message_id</code>, если сообщение отправлено в инлайн-режиме.</p><p>Приведу пример, после которого все вопросы должны отпасть: пусть, например, если сообщение отправлено ботом в обычном режиме, то нажатие на кнопку заменит текст сообщения на &ldquo;Пыщь&rdquo;, если в инлайн – то &ldquo;Бдыщь&rdquo;. При этом в обоих случаях значение <code>callback_data</code> будет равно <code>test</code>. Что для этого нужно сделать: во-первых, написать простейший хэндлер для всех входящих сообщений, во-вторых, написать простейший хэндлер для инлайн-сообщений, в-третьих, написать простейший хэндлер для колбэка, который определит, из какого режима пришло сообщение.</p><pre><code class=language-none data-lang=none># Обычный режим
@bot.message_handler(content_types=["text"])
def any_msg(message):
    keyboard = types.InlineKeyboardMarkup()
    callback_button = types.InlineKeyboardButton(text="Нажми меня", callback_data="test")
    keyboard.add(callback_button)
    bot.send_message(message.chat.id, "Я – сообщение из обычного режима", reply_markup=keyboard)


# Инлайн-режим с непустым запросом
@bot.inline_handler(lambda query: len(query.query) > 0)
def query_text(query):
    kb = types.InlineKeyboardMarkup()
    # Добавляем колбэк-кнопку с содержимым "test"
    kb.add(types.InlineKeyboardButton(text="Нажми меня", callback_data="test"))
    results = []
    single_msg = types.InlineQueryResultArticle(
        id="1", title="Press me",
        input_message_content=types.InputTextMessageContent(message_text="Я – сообщение из инлайн-режима"),
        reply_markup=kb
    )
    results.append(single_msg)
    bot.answer_inline_query(query.id, results)


# В большинстве случаев целесообразно разбить этот хэндлер на несколько маленьких
@bot.callback_query_handler(func=lambda call: True)
def callback_inline(call):
    # Если сообщение из чата с ботом
    if call.message:
        if call.data == "test":
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text="Пыщь")
    # Если сообщение из инлайн-режима
    elif call.inline_message_id:
        if call.data == "test":
            bot.edit_message_text(inline_message_id=call.inline_message_id, text="Бдыщь")

if __name__ == '__main__':
    bot.infinity_polling()</code></pre><p>Запускаем бота, отправляем инлайн-сообщение, которое, в свою очередь, вызовет обычное:</p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/test-web/images/l8_2.png alt><figcaption><h4><i></i></h4></figcaption></figure></center><p>Нажмем на обе кнопки, результат правильный:</p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/test-web/images/l8_3.png alt="После проверки"><figcaption><h4><i>После проверки</i></h4></figcaption></figure></center><p>Таким образом, callback-кнопки – это очень мощный инструмент для взаимодействия пользователей с ботом, а редактирование сообщений дополнительно помогает в этом.
Более того, нажатие на колбэк-кнопку может дополнительно тригернуть либо уведомление в верхней части экрана, либо всплывающее окно. Покажу первый вариант. Пускай помимо изменения сообщения на &ldquo;Пыщь&rdquo;, аналогичное слово показывается уведомлением. Для этого перепишем первое if-условие в хендлере колбэков:</p><pre><code class=language-none data-lang=none>if call.message:
    if call.data == "test":
        bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text="Пыщь")
        bot.answer_callback_query(callback_query_id=call.id, show_alert=False, text="Пыщь!")</code></pre><p>Результат – на скриншоте. Попробуйте, кстати, изменить аргумент <code>show_alert</code> на <code>True</code> и посмотрите, что получится.</p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/test-web/images/l8_4.png alt="Всплывающее уведомление"><figcaption><h4><i>Всплывающее уведомление</i></h4></figcaption></figure></center><h3 id=switch->Switch-кнопки</h3><p>Наконец, остался последний тип кнопок - <strong>Switch</strong> (переключатель). Они нужны, чаще всего, для обучения пользователей работе с ботом в инлайн-режиме. Чтобы активировать сделать кнопку такого типа, нужно указать аргумент <code>switch_inline_query</code> либо пустой, либо с каким-либо текстом. В последнем случае этот текст будет сразу подставлен в поле ввода, например, для показа демонстрации инлайна. Как вообще работает такая кнопка? При нажатии на неё Telegram предложит выбрать чат, после чего подставит в поле ввода ник вашего бота и (если есть), текст, указанный вами в аргументе <code>switch_inline_query</code>. Давайте попробуем так сделать. Добавим кнопку, которая будет перенаправлять пользователя в какой-либо чат и предлагать в инлайн-режиме запрос &ldquo;Telegram&rdquo;. Код всего хендлера выглядит вот так:</p><pre><code class=language-none data-lang=none>@bot.message_handler(content_types=["text"])
def any_msg(message):
    keyboard = types.InlineKeyboardMarkup()
    switch_button = types.InlineKeyboardButton(text="Нажми меня", switch_inline_query="Telegram")
    keyboard.add(switch_button)
    bot.send_message(message.chat.id, "Я – сообщение из обычного режима", reply_markup=keyboard)</code></pre><p>Теперь, если мы нажмем на кнопку и выберем чат, вот что получится:</p><center><figure style="padding:.25rem;margin:1rem 0"><img style=max-width:100%;height:auto src=/test-web/images/l8_5.png alt=Результат><figcaption><h4><i>Результат</i></h4></figcaption></figure></center><p>Итак, в этом уроке мы познакомились с новыми кнопками в Telegram Bot API, научились <del>переписывать историю</del> редактировать сообщения и отправлять небольшие уведомления по нажатию. В следующий раз продолжим изучать новые возможности для ботов.
А исходники к этому уроку можно найти в <a href=https://github.com/MasterGroosha/telegram-tutorial>этом репозитории</a></p><p><a href=/telegram-tutorial/docs/lesson_07/ class=book-btn style=float:left>← Урок №7</a>
<a href=/telegram-tutorial/docs/lesson_09/ class=book-btn style=float:right>Урок №9 →</a></p></article></div><aside class="book-toc level-3 fixed"><nav id=TableOfContents><ul><li><a href=#heading>Введение</a></li><li><a href=#->Новые возможности</a><ul><li><a href=#url->URL-кнопки</a></li><li><a href=#callback---->Callback-кнопки и редактирование сообщений</a></li><li><a href=#switch->Switch-кнопки</a></li></ul></li></ul></nav></aside></main></body></html>